---
title: This is my title
---
[[toc]]
## Типы данных

- Примитивные: `string`, `number`, `bigint`, `boolean`, `null`, `undefined`, `symbol`
- Объектные: `Object` (включает массивы, функции, даты и др.).

## Переменные 

- `let`: позволяет объявить изменяемую переменную с блочной областью видимости.
- `const`: позволяет объявить неизменяемую переменную (константу) с блочной областью видимости.
- `var`: старая форма объявления, имеет функциональную область видимости и подвержена хостингу.

## Hoisting 

Hoisting в JavaScript - это поведение, при котором объявления переменных и функций перемещаются вверх по своей области видимости перед выполнением кода. Это означает, что переменные и функции могут быть использованы до того, как они фактически объявлены в коде.

---
Для переменных, объявленных с использованием ключевого слова `var`, hoisting перемещает только объявление переменной в начало области видимости, но не ее инициализацию. Это означает, что если переменная используется до ее объявления, она будет иметь значение undefined.

```js
test = 1;
var test;
```

### Что происходит:
Хоистинг (hoisting) переменной test:

- При использовании var переменные поднимаются (hoist) в начало своей области видимости, но их инициализация остается на месте.
- Таким образом, код интерпретируется так, как будто var test; написано выше всего остального.
---
Для функций, объявленных как функциональные выражения, hoisting перемещает только объявление переменной, но не определение функции. Между тем, для функций, объявленных как функциональные декларации, hoisting перемещает и объявление, и определение функции в верхнюю часть области видимости, что позволяет вызывать функцию до ее объявления в коде.

Ключевые слова `let` и `const` также подвергаются hoisting, но они находятся во временной мертвой зоне (TDZ - Temporal Dead Zone) до тех пор, пока не будут инициализированы, что означает, что к ним нельзя обратиться до их объявления.
![temporal-dead-zone.png](..%2Fpublic%2Ftemporal-dead-zone.png)
## Functions

### Function Declaration

```js
function sum(a, b) {
  return a + b;
}
```

### Function Expression

```js
let sum = function(a, b) {
  return a + b;
};
```
Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

С Function Declaration всё иначе.

Function Declaration может быть вызвана раньше, чем она объявлена.

## Callback
Это функции, которые передаются в качестве аргументов другим функциям для последующего вызова.

## Чистая функция 
`Чистая функция` — это функция, которая обладает двумя основными свойствами:
- Возвращаемое значение функции зависит только от её входных значений, без каких-либо внешних воздействий. То есть вызов функции с теми же аргументами всегда даст один и тот же результат.
- Функция не изменяет никакие состояния или данные за пределами своего контекста и не взаимодействует с внешним миром (например, не изменяет глобальные переменные, не пишет данные на диск и т.д.).
```js
function sum(a, b) {
    return a + b;
}
```
Эта функция всегда возвращает одно и то же значение при одинаковых аргументах и не производит никаких внешних изменений в системе.

## Currying function `sum()()`
```js
function sum(a) {
    return function(b) {
        return a + b;
    };
}

console.log(sum(3)(5)) // summa 8
```

## Операторы сравнения
### Нестрогое сравнение `==`
Строгое сравнение приводит к одному типу

Например: 
```js
alert( '01' == 1 ); // true, строка '01' становится числом 1

console.log(null == undefined); // true
console.log(null == 0); // false
console.log(undefined == false); // false
```
Логическое значение true становится 1, а false – 0.
Например:
```js
alert( true == 1 ); // true
alert( false == 0 ); // true
```
### Строгое равенство `===`
Проверяет равенство без приведения типов.
```js
alert( 0 === false ); // false, так как сравниваются разные типы
```
### Сравнение с null и undefined
При строгом равенстве `===`
Эти значения различны, так как различны их типы.
```js
alert( null === undefined ); // false
```
При нестрогом равенстве `==`
Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.
```js
alert( null == undefined ); // true
```
При использовании математических операторов и других операторов сравнения `<` `>` `<=` `>=`
Значения `null/undefined` преобразуются к числам: `null` становится `0`, а `undefined` – `NaN`.

## Логические операторы 
- `||` (ИЛИ)
  `||=` (Оператор логического присваивания ИЛИ)
- `&&` (И)
  `&&=` (Оператор логического присваивания И)
- `!` (НЕ)
- `??` (Оператор нулевого слияния)
  `??=` (Оператор нулевого присваивания)

## Объекты
Объекты – это ассоциативные массивы с рядом дополнительных возможностей.
Они хранят свойства (пары ключ-значение), где:
- Ключи свойств должны быть строками или символами (обычно строками).
- Значения могут быть любого типа.

Чтобы получить доступ к свойству, мы можем использовать:
- Запись через точку: `obj.property`.
- Квадратные скобки `obj["property"]`. Квадратные скобки позволяют взять ключ из переменной, например, obj[varWithKey].

Дополнительные операторы:
- Удаление свойства: `delete obj.prop`.
- Проверка существования свойства: `"key" in obj`.
- Перебор свойств объекта: цикл for in `for (let key in obj)`.

Способы создания объектов: 
- Самый простой и распространённый способ:
```js
const person = {
  name: 'Alice',
  age: 25,
  greet: function() {
    console.log('Hello!');
  }
};
console.log(person.name); // 'Alice'
person.greet(); // 'Hello!'
```
- Конструктор Object
```js
const person = new Object();
person.name = 'Bob';
person.age = 30;
person.greet = function() {
  console.log('Hi there!');
};
console.log(person.name); // 'Bob'
person.greet(); // 'Hi there!'
```
Копирование объекта, `Object.assign`:
```js
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект

// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}

// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные

alert( user.name ); // все ещё John в первоначальном объекте
```
Также мы можем использовать для этого метод `Object.assign`.

```js
Object.assign(dest, [src1, src2, src3...])
```
- Первый аргумент dest — целевой объект.
- Остальные аргументы src1, ..., srcN (может быть столько, сколько необходимо) являются исходными объектами
- Метод копирует свойства всех исходных объектов src1, ..., srcN в целевой объект dest. Другими словами, свойства всех аргументов, начиная со второго, копируются в первый объект.
- Возвращает объект dest.
  
Также существуют и другие методы клонирования объекта. Например, с использованием оператора расширения `...spred` `clone = {...user}`

### Object.keys, Object.values, Object.entries
Для простых объектов доступны следующие методы:
- `Object.keys(obj)` – возвращает массив ключей.
- `Object.values(obj)` – возвращает массив значений.
- `Object.entries(obj)` – возвращает массив пар [ключ, значение].

## Массивы
### Методы массивов
Для добавления/удаления элементов:
- `push(...items)` – добавляет элементы в конец,
- `pop()` – извлекает элемент с конца,
- `shift()` – извлекает элемент с начала,
- `unshift(...items)` – добавляет элементы в начало.
- `splice(pos, deleteCount, ...items)` – начиная с индекса pos удаляет deleteCount элементов и вставляет items.
- `slice(start, end)` – создаёт новый массив, копируя в него элементы с индекса start до end (не включая end).
- `concat(...items)` – возвращает новый массив: копирует все члены текущего массива и добавляет к нему items. Если какой-то из items является массивом, тогда берутся его элементы.

Для поиска среди элементов:
- `indexOf/lastIndexOf(item, pos)` – ищет item, начиная с позиции pos, и возвращает его индекс или -1, если ничего не найдено.
- `includes(value)` – возвращает true, если в массиве имеется элемент value, в противном случае false.
- `find/filter(func)` – фильтрует элементы через функцию и отдаёт первое/все значения, при прохождении которых через функцию возвращается true.
- `findIndex` похож на find, но возвращает индекс вместо значения.

Для перебора элементов:
- `forEach(func)` – вызывает func для каждого элемента. Ничего не возвращает.

Для преобразования массива:
- `map(func)` – создаёт новый массив из результатов вызова func для каждого элемента.
- `sort(func)` – сортирует массив «на месте», а потом возвращает его.
- `reverse()` – «на месте» меняет порядок следования элементов на противоположный и возвращает изменённый массив.
- `split/join` – преобразует строку в массив и обратно.
- `reduce/reduceRight(func, initial)` – вычисляет одно значение на основе всего массива, вызывая func для каждого элемента и передавая промежуточный результат между вызовами.

### Мутация массивов - изменяет исходный массив.
`push`, `pop`, `shift`, `unshift`, `sort`, `reverse` и `splice`

`arr.some(fn)/arr.every(fn)` проверяет массив.

Функция fn вызывается для каждого элемента массива аналогично map. Если какие-либо/все результаты вызовов являются true, то метод возвращает true, иначе false.
Эти методы ведут себя примерно так же, как операторы || и &&: если fn возвращает истинное значение, `arr.some()` немедленно возвращает true и останавливает перебор остальных элементов; если fn возвращает ложное значение, `arr.every()` немедленно возвращает false и также прекращает перебор остальных элементов.

## Остаточные параметры и оператор расширения `rest`, `spred`
Когда мы видим `...` в коде, это могут быть как остаточные параметры, так и оператор расширения.

Как отличить их друг от друга:
- Если `...` располагается в конце списка параметров функции, то это «остаточные параметры»`rest`. Он собирает остальные неуказанные аргументы и делает из них массив.
- Если `...` встретился в вызове функции или где-либо ещё, то это «оператор расширения»`spred`. Он извлекает элементы из массива.

## Promise
```js
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});
```
Её аргументы `resolve` и `reject` – это колбэки.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- `resolve(value)` — если работа завершилась успешно, с результатом `value`.
- `reject(error)` — если произошла ошибка, error – объект ошибки.

У объекта promise, возвращаемого конструктором `new Promise`, есть внутренние свойства:

- `state («состояние»)` — вначале `pending («ожидание»)`, потом меняется на `fulfilled («выполнено успешно»)` при вызове `resolve` или на `rejected («выполнено с ошибкой»)` при вызове `reject`.
- `result («результат»)` — вначале undefined, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

::: info
Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.
Все последующие вызовы `resolve` и `reject` будут проигнорированы:

```js
let promise = new Promise(function(resolve, reject) {
  resolve("done");

  reject(new Error("…")); // игнорируется
  setTimeout(() => resolve("…")); // игнорируется
});
```
Также заметим, что функция `resolve/reject` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.
:::

### Для обработки результата следует использовать методы `.then/``.catch/``.finally`
### `.then`
```js
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```
- Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.
- Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

### `.catch`
Если мы хотели бы только обработать ошибку, то можно использовать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Или можно воспользоваться методом `.catch(errorHandlingFunction)`, который сделает то же самое
```js
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```

### `.finally`
Принцип такой же как у конструкции `try...catch...finally`

## `try...catch...finaly`
Конструкция `try..catch` позволяет обрабатывать ошибки во время исполнения кода. Она позволяет запустить код и перехватить ошибки, которые могут в нём возникнуть.
```js
try {
  // исполняем код
} catch(err) {
  // если случилась ошибка, прыгаем сюда
  // err - это объект ошибки
} finally {
  // выполняется всегда после try/catch
}
```
Секций `catch` или `finally` может не быть, то есть более короткие конструкции `try..catch` и `try..finally` также корректны.

## Promise API 

- `Promise.all(promises)` – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы Promise.all будет эта ошибка, результаты остальных промисов будут игнорироваться.
- `Promise.allSettled(promises)` (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
status: "fulfilled", если выполнен успешно или "rejected", если ошибка,
value – результат, если успешно или reason – ошибка, если нет.
- `Promise.race(promises)` – ожидает первый выполненный промис, который становится его результатом, остальные игнорируются.
- `Promise.any(promises)` (добавлен недавно) – ожидает первый успешно выполненный промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, AggregateError становится ошибкой Promise.any.
- `Promise.resolve(value)` – возвращает успешно выполнившийся промис с результатом value.
- `Promise.reject(error)` – возвращает промис с ошибкой error.

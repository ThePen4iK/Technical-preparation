## Жизненный цикл компонента
### useEffect
```js
useEffect(() => {
  // Логіка ефекту
}, []); //масив залежностей
```
- `componentDidMount`
- `componentDidUpdate`
- `componentWillUnmount`

```js
const Counter = () => {
  // Використання хука useState для створення стану
  const [count, setCount] = useState(0);
  // Ефект, що виконується при монтуванні компонента
  useEffect(() => {
    // Код, що виконується при монтуванні компонента
    console.log("Component mounted");
    // Функція очищення, що виконується перед видаленням компонента з DOM
    return () => {
      // Код, що виконується перед знищенням компонента
      console.log("Component unmounted");
      setCount(0);
    };
  }, []); // Порожній масив залежностей означає, що ефект виконується тільки при монтуванні та розмонтуванні компонента
  // Функція для збільшення значення лічильника
  const increment = () => {
    setCount(count + 1);
  };
  // Рендер компонента
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
};

export default Counter;
```

## Оптимизация
### React.memo
Она позволяет кэшировать результаты рендеринга компонентов и перендерировать их только при изменении входных свойств (props).

Когда мы используем `React.memo` для обертывания функционального компонента, React автоматически проверяет входные props компонента во время рендеринга. Если значения входных реквизитов не изменяются, React повторно использует кэшированный результат рендеринга компонента вместо выполнения повторного рендеринга.

```js
const MyComponent = (props) => {
  // Код компонента
};

export default React.memo(MyComponent);
```
Если нам надо перерендовать только при изменении определенных входных props, а остальные свойства компонента остаются неизменными
Мы используем аргументы которые применяет в себя `React.memo` это первый аргумент - компонент, а второй - функции сравнения `prevProps(предыдущий)` и `nextProps(следующий)`,
```js
const MyComponent = ({ prop1, prop2 }) => {
  // Код компонента
  return (
    <div>
      {/* Використовуємо значення prop1 */}
      <p>Prop1: {prop1}</p>
      {/* Використовуємо значення prop2 */}
      <p>Prop2: {prop2}</p>
    </div>
  );
};
// Використовуємо React.memo для оптимізації рендерингу
export default React.memo(MyComponent, (prevProps, nextProps) => {
  // Перевіряємо, чи змінився тільки prop1, а prop2 залишився незмінним
  return prevProps.prop1 === nextProps.prop1;
});
```

### useMemo
Позволяет оптимизировать рендеринг компонентов, предотвратить ненужные перечисления.

`useMemo` використовується для кешування результатів обчислень і повертає закешоване значення, якщо вхідні залежності не змінилися. 
```js
const MyComponent = ({ a, b }) => {
  // Використання useMemo для кешування результату обчислення
  const result = useMemo(() => {
    console.log('Результат обчислення');
    return a + b;
  }, [a, b]); // Залежності, на основі яких буде виконано повторне обчислення
  return (
    <div>
      <p>Результат: {result}</p>
    </div>
  );
};
export default MyComponent;
```

### useCallback
Позволяет кэшировать мемоизированную версию функции между рендерами компонента.
Возвращает мемоизированную версию функции, которая будет одинаковой при каждом рендере компонента, пока не изменится ни одна зависимость из массива зависимостей.

Это позволяет избежать ненужного создания новых функций при каждом рендере компонента, что может происходить в некоторых случаях, когда мы передаем функции как пропсы к дочерним компонентам.
```js
const ParentComponent = () => {
  const [count, setCount] = useState(0);
  // Оголошуємо функцію-обробник кліку з використанням useCallback,
  // передаємо залежність [count]
  const handleClick = useCallback(() => {
    console.log('Функція-обробник кліку викликається');
    setCount(count + 1);
  }, [count]);

  return (
    <div>
      <h1>Лічильник: {count}</h1>
      {/* Передаємо функцію-обробник як пропс до дочірнього компонента */}
      <ChildComponent handleClick={handleClick} />
    </div>
  );
};
export default ParentComponent;
```
